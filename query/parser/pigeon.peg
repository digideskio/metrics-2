{

// initialization goes here

}

Root <- expr:(SelectStatement / DescribeStatement) _ EOF {
  return expr, nil
}

SelectStatement <-
  _ ("select" KEY)?
  list:ExpressionList
  predicateClause:OptionalPredicateClause
  propertyClause:PropertyClause {
  return makeSelect(list, predicateClause, propertyClause) // TODO: makeSelect
}

DescribeStatement <-
  _ "describe" KEY
  statement:(DescribeAllStatement / DescribeMetricsStatement / DescribeSingleStatement) {
  return statement, nil
}

DescribeAllStatement <-
  _ "all" KEY
  matchClause:OptionalMatchClause {
  return makeDescribeAll(matchClause) // TODO: makeDescribeAll
}

OptionalMatchClause <- MatchClause / { return makeNullMatchClause() } // TODO: makeNullMatchClause

MatchClause <-
  _ "match" KEY
  literal:LiteralString {
  return makeMatchClause(literal) // TODO: makeMatchClause
}

DescribeMetrics <-
  _ "metrics" KEY
  _ "where" KEY
  tagName:MetricName
  _ "="
  tagValue:LiteralString {
  return makeDescribeMetrics(tagName, tagValue) // TODO: makeDescribeMetrics
}

DescribeSingleStatement <-
  name:MetricName // TODO: METRIC_NAME => MetricName
  predicateClause:OptionalPredicateClause {
  return makeDescribeSingleStatement(name, predicateClause) // TODO: makeDescribeSingleStatement
}

UncheckedPropertyClause <-
  propertyList:(
      _ key:PropertyKey
      _ value:PropertyValue
      { return makePropertyKeyValuePair(key, value) } // TODO: makePropertyKeyValuePair
  )* {
  return makePropertyClause(propertyList) // TODO: makePropertyClause
}

PropertyClause <- clause:UncheckedPropertyClause {
  return checkPropertyClause(clause) // TODO: checkPropertyClause
}

OptionalPredicateClause <- PredicateClause / { makeNullPredicate() } // TODO: makeNullPredicate

ExpressionList <-
  first:Expression
  rest: ( _ "," expression:Expression { return expression, nil } )*
  {
  return append([]function.Expression{first}, rest...), nil // TODO: does this work?
}

Expression <- sum:ExpressionSum pipe:AddPipe { return addPipe(sum, pipe) } // TODO: implement addPipe

ExpressionSum <-
  first:ExpressionProduct
  suffixes:(
    pipes:OnePipe*
    op:(_ op:("+" / "-") {return op, nil})
    right:ExpressionProduct
    { return makeExpressionSuffix(pipes, op, right) } // TODO: makeExpressionSuffix
  )*
  { return makeOperator(first, suffixes) } // TODO: makeOperator

ExpressionProduct <-
  first:ExpressionAtom
  suffixes:(
    pipes:OnePipe*
    op:(_ op:("*" / "/") {return op, nil})
    right:ExpressionAtom
    { return makeExpressionSuffix(pipes, op, right) } // TODO: makeExpressionSuffix
  )*
  { return makeOperator(first, suffixes) } // TODO: makeOperator

OnePipe <-
  _ "|"
  _ name:Identifier // TODO: Identifier
  arguments:(CallArguments / { return nil, nil })
  { return makeOnePipe(name, arguments) } // TODO: makeOnePipe

CallArguments <-
  _ "("
  arguments:((first:Expression rest:(_ "," right:Expression)*) / { return nil, nil })
  // TODO: group by
  _ ")"
  { return arguments, nil }

ExpressionAtom <-
  core:ExpressionRaw
  annotation:ExpressionAnnotation
  { if annotation != "" { return makeAnnotation(core, annotation) } return core, nil } // TODO: makeAnnotation

ExpressionRaw <- ExpressionFunction / ExpressionMetric / _ "(" item:Expression _ ")" {return item, nil} / Duration / Scalar / String

ExpressionAnnotationRequired <- _ "{" contents:[^}] "}" { return contents, nil }
ExpressionAnnotation <- ExpressionAnnotationRequires / { return "", nil }

OptionalGroupBy <- GroupByClause / CollapseByClause / { return function.Groups{}, nil } // TODO: what to return here

ExpressionFunction <-
  name:Identifier
  arguments:CallArguments
  { return makeFunctionCall(name, arguments) } // TODO: makeFunctionCall

ExpressionMetric <-
  name:Identifier
  predicate: (_ "[" predicate:Predicate _ "]" { return predicate, nil } / { return makeNullPredicate() })
  { return makeMetricExpression(name, predicate) } // TODO: makeMetricExpression

GroupByClause <-
  _ "group" KEY
  _ "by" KEY
  first:Identifier // TODO: is this actually identifier? Originally COLUMN_NAME
  rest:(_ "," Identifier)*
  { return makeGroupBy(first, rest) } // TODO: makeGroupBy

CollapseByClause <-
  _ "collapse" KEY
  _ "by" KEY
  first:Identifier // TODO: is this actually identifier? Originally COLUMN_NAME
  rest:(_ "," Identifier)*
  { return makeCollapseBy(first, rest) } // TODO: makeGroupBy

PredicateClause <-
  _ "where" KEY
  predicate:Predicate
  { return predicate, nil }

Predicate <- PredicateDisjunction

PredicateDisjunction <-
  left:PredicateConjunction _ "or" KEY right:PredicateDisjunction { return makeOrPredicate(left, right) } // TODO: makeOrPredicate
  /
  PredicateConjunction

PredicateConjunction <-
  left:PredicateAtom _ "and" KEY right:PredicateConjunction { return makeAndPredicate(left, right) } // TODO: makeAndPredicate
  /
  PredicateAtom

PredicateAtom <-
  _ "not" atom:PredicateAtom { return makeNotPredicate(atom) } // TODO: makeNotPredicate
  /
  _ "(" predicate:Predicate _ ")" { return predicate, nil }
  /
  TagMatcher

TagMatcher <-
  name:Identifer _ "=" literal:LiteralString { return makeLiteralMatcher(name, literal), nil } // TODO: makeLiteralMatcher, name was tagName, not Identifier
  /
  name:Identifier _ "!=" literal:LiteralString { return makeNotPredicate(atom, makeLiteralMatcher(name, literal)), nil }
  /
  name:Identifier _ "match" KEY literal:LiteralString { return makeRegexMatcher(name, literal), nil } // TODO: makeRegexMatcher
  /
  name:Identifier _ "in" KEY list:LiteralList { return makeListMatcher(name, list), nil } // TODO: makeListMatcher

LiteralString <- _ "\"" contents:([^"] / "\\\"")* "\"" { return unescape(contents), nil } // TODO: unescape

LiteralList <-
  _ "("
  first:LiteralString
  rest:(_ "," literal:LiteralString { return literal, nil })
  _ ")"
  { return makeLiteralList(first, rest), nil } // TODO: makeLiteralList

Identifier <-
  "`" contents:CHAR* "`" { return contents, nil}
  /
  _ !(KEYWORD KEY) first:Segment rest:("." segment:Segment { return segment, nil })* { return makeIdentifier(first, rest), nil } // TODO: makeIdentifier

Segment <- IDStart IDContinue*

IDStart <- [a-zA-Z_]
IDContinue <- IDStart / [0-9]

Timestamp <- number:NumberInteger suffix:[a-z]* { return number + suffix, nil } / LiteralString / _ "now" KEY { return "now", nil }

_ "whitespace" <- [ \n\t\r]*

EOF <- !.

PropertyKey

///

PropertyKey <- "from" KEY / "to" KEY / "sample" KEY _ "by" KEY { return "sample", nil }

PropertyValue <- Timestamp // ???

KEYWORD <-     # List of keywrods used throughout the code.
  "all" KEY /
  "and" KEY /
  "as" KEY /
  "by" KEY /
  "describe" KEY /
  "group" KEY /
  "collapse" KEY /
  "in" KEY /
  "match" KEY /
  "not" KEY /
  "or" KEY /
  "select" KEY /
  "where" KEY /
  "metrics" KEY /
  PROPERTY_KEY

Number <- NumberInteger NumberFraction? NumberExponent?
NumberInteger <- "-"? NumberNatural
NumberNatural <- "0" / [1-9] [0-9]*
NumberFraction <- "." [0-9]+
NumberExponent <- [eE] ("+" / "-")? [0-9]+

Duration <- NumberInteger [a-z]+

KEY <- !([a-zA-Z0-9])

_  <-          (SPACE / COMMENT_TRAIL / COMMENT_BLOCK)* # Optional spaces
COMMENT_TRAIL  <- "--" (!"\n" .)*
COMMENT_BLOCK  <- "/*" (!"*/" .)* "*/"
KEY <-         !ID_CONT
SPACE <-       " " / "\n" / "\t"
